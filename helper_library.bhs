labels {
	PI = 3.14159
}

// Will return a city's name from its building ID. Nation ID also required
String scenario city_name_from_id(int who, int b_id) {
	for (int i = 0; i < num_cities(who); ++i) {
		string city_name = find_city_name(who);
		int city_id = find_city_id(city_name);
		if (city_id == b_id) {
			return city_name;
		}
	}
	
	return "[city_name_from_id failed!]";
}

// Struct that contains data about cities. Keeps things nice and organized, no multidimensional arrays either.
struct City
{
  int nation;
  string name;
  int last_hp;
  int hp;
  int uid;
  int time_nuked;	// The gametime in minutes that the city was nuked. We will check all nuked cities regularly and compare this value to the current gametime.
};					// if cur_time - time_nuked >= 10, then reset time_nuked and stop the fallout effect

// Array helper functions

// Returns the INDEX of the city we're looking for by name
int scenario get_element_by_name(ref City[] arr, string _name) {
	for (int k = 0; k < arr.length; k++) {
		if (arr[k].name == _name) {
			return k;
		}
	}
	return -1;	// failed
}

// Push an element onto the end of an array. 'ref' keyword just means the argument is being passed by reference in Big Huge Script. (these comments are for my future self)
void scenario add_city(ref City[] arr, City data) {
	
	// check if city exists in array
	int index = get_element_by_name(arr, data.name);
	
	if (index >= 0)  {	// city already exists, update it
		arr[index].name = data.name;
		arr[index].nation = data.nation;
		arr[index].hp = data.hp;
	} else {	// add it otherwise
		arr[arr.length] = data;
	}
}

// Note: we may want to implement our own Timer system because per the scripting manual: "Setting too many timers can cause them not to fire."
// I'm going to use the built-in timers at first, but if it becomes a problem I'll write my own system. time_min and time_sec will be useful functions for that.