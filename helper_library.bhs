// helper_library.bhs

labels {
	
}

struct City
{
  int nation;
  string name;
  int last_hp;
  int hp;
  int id;
  int time_nuked;
};

int scenario get_element_by_id(ref City[] arr, City c) {
	for (int k = 0; k < arr.length; k++) {
		if (arr[k].id == c.id && arr[k].nation == c.nation) {
			return k;
		}
	}
	return -1;	// failed
}

void scenario damage_all_in_city(City c, int dmg_percent, int dmg_radius) {
	set_object_health(c.nation, c.id, 1);	// keep city at 1% health for duration

	int first = find_build_at_city(c.nation, c.name, "", 1); // call it once to skip the city and to start looping at the 2nd building
	int cur_bldg = 0;
	while (cur_bldg != first) {
		cur_bldg = find_build_at_city(c.nation, c.name, "", 1);
		
		if (cur_bldg != c.id) {
			damage_object(c.nation, cur_bldg, dmg_percent);
		}
	}
	
	// for every nation
	for (int i = 1; i < 9; i++) {
		// for every unit in that nation
		for (int j = 0; j < num_units(i); j++) {
			int unit_id = find_all_unit(i, "");
			// check if near city that has been nuked
			if (object_near_build(i, unit_id, c.nation, c.id, dmg_radius)) {
				if (object_health(i, unit_id) <= 20) {	// preserve death animations
					kill_unit_anim(i, unit_id, 2);
				} else {
					damage_object(i, unit_id, dmg_percent);
				}
			}
		}
	}
}

void scenario add_city(ref City[] arr, City data) {
	int index = get_city_index(arr, data);
	
	if (index >= 0)  {
		arr[index].name = data.name;
		arr[index].nation = data.nation;
		arr[index].hp = data.hp;
		arr[index].id = data.id;
	} else {
		arr[arr.length] = data;
	}
}
